//
//  Glider
//  Fast, Lightweight yet powerful logging system for Swift.
//
//  Created by Daniele Margutti
//  Email: <hello@danielemargutti.com>
//  Web: <http://www.danielemargutti.com>
//
//  Copyright Â©2022 Daniele Margutti. All rights reserved.
//  Licensed under MIT License.
//

import Foundation

/// This is the payload for `SysLogFormatter`.
/// You don't need to allocate this kind of object but it's
/// generated by the Glider's payload object when using this formatter.
///
/// More infos about the structure are available [here](https://tools.ietf.org/html/rfc5424#section-6.2.3).
internal struct SysLogPayload {
    
    // MARK: - Private Properties
    
    private static let defaultDateFormat: String = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZZ"
    private static let posixLocaleID: String = "en_US_POSIX"

    private static let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: Self.posixLocaleID)
        formatter.dateFormat = Self.defaultDateFormat
        formatter.timeZone = .current
        return formatter
    }()

    // MARK: - Properties
    
    /// Metadata
    let metadata: MessageMetadata
    
    /// Structured Payload.
    let structured: StructuredPart
    
    /// Message.
    let message: String

    // MARK: - Initialization
    
    init(metadata: MessageMetadata, structured: StructuredPart, message: String) {
        self.metadata = metadata
        self.structured = structured
        self.message = message.inlineSafeValue
    }
    
    /// initialize from glider's payload.
    ///
    /// - Parameter payload: payload.
    init(event: Event, hostname: String, extraFields: [FieldsFormatter.Field]) {
        self.message = event.message.description.inlineSafeValue
        self.metadata = MessageMetadata(date: event.timestamp, hostname: hostname)
        self.structured = StructuredPart(event.stringRepresentableValueForFormattedFields(extraFields))
    }

    func formatted() -> String {
        return "\(metadata.formatted(withFormatter: Self.dateFormatter)) \(structured.formatted()) \(message)\n"
    }

}

extension Event {
    
    /// Return all fields with string representable values from event.
    ///
    /// - Parameter fields: fields to retrive.
    /// - Returns: [String: String]
    func stringRepresentableValueForFormattedFields(_ fields: [FieldsFormatter.Field]) -> [String: String] {
        var dict = [String: String]()
        
        for field in fields {
            if let value = valueForFormatterField(field) as? String,
               let key = field.label ?? field.field.defaultLabel {
                dict[key] = value
            }
        }
        
        return dict
    }
    
}

// MARK: - Supported Structures

internal extension SysLogPayload {
    
    // MARK: - MessageMetadata
    
    /// `MessageMetadata` is a struct used to attach metadata for configuring each
    /// syslog message.
    ///
    /// See <https://tools.ietf.org/html/rfc5424#page-8>
    /// for further details on supported fields.
    struct MessageMetadata {
        let priority: Int
        let date: Date
        let hostname: String
        let application: String
        let extended: [String: String]?
        private let facility: SyslogFacility = .user

        init(severity: SyslogSeverity = .info, date: Date, application: String? = nil, hostname: String, extended: [String: String]? = nil) {
            priority = severity.rawValue + facility.rawValue * 8
            self.date = date
            self.application = (application ?? ProcessIdentification.shared.applicationInfo).withoutSpaces
            self.hostname = hostname.withoutSpaces
            self.extended = extended
        }

        func formatted(withFormatter dateFormatter: DateFormatter) -> String {
            return "<\(priority)>1 \(dateFormatter.string(from: date)) \(hostname) \(application) - -"
        }
    }
    
    // MARK: - StructuredPart

    struct StructuredPart {
        let data: [String: String]

        init(_ data: [String: String]) {
            self.data = data
        }

        func formatted() -> String {
            "[meta \(data.map { "\($0.0)=\"\($0.1)\"" }.joined(separator: " "))]"
        }
    }
    
    // MARK: - SyslogSeverity
    
    /// Severity level to attach to log message.
    ///
    /// See:
    ///
    /// - https://en.wikipedia.org/wiki/Syslog#Severity_level
    /// - https://tools.ietf.org/html/rfc5424#section-6.2.1
    ///
    /// for full documentation.
    enum SyslogSeverity: Int {
        case emergency = 0
        case alert
        case critical
        case error
        case warning
        case notice
        case info
        case debug
        
        /// Initialize from payload's level of severity.
        ///
        /// - Parameter level: level.
        init(logLevel level: Level) {
            switch level {
            case .trace: self = .debug
            case .debug: self = .debug
            case .info: self = .debug
            case .notice: self = .notice
            case .warning: self = .warning
            case .error, .alert: self = .error
            case .critical, .emergency: self = .critical
            }
        }
    }

    // MARK: - SyslogFacility

    /// Facility code to attach to log message.
    ///
    /// See:
    ///
    /// - https://en.wikipedia.org/wiki/Syslog#Facility
    /// - https://tools.ietf.org/html/rfc5424#section-6.2.1
    ///
    /// for full documentation.
    enum SyslogFacility: Int {
        case kernel = 0
        case user
        case mail
        case daemon
        case auth
        case syslog
        case lpr
        case news
        case uucp
        case clock
        case authpriv
        case ftp
        case ntp
        case audit
        case alert
        case cron
        case local0
        case local1
        case local2
        case local3
        case local4
        case local5
        case local6
        case local7
    }
    
}

// MARK: - Supporting Extensions

fileprivate extension String {
    
    var inlineSafeValue: String {
        replacingOccurrences(of: "\n", with: " ")
    }

    var withoutSpaces: String {
        replacingOccurrences(of: " ", with: "_")
    }
    
}
